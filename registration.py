"""
Student information for this assignment:

Replace Varun Venkatesh with your name.
On my/our honor, Varun Venkatesh, this
programming assignment is my own work and I have not provided this code to
any other student.

I have read and understand the course syllabus's guidelines regarding Academic
Integrity. I understand that if I violate the Academic Integrity policy (e.g.
copy code from someone else, have the code generated by an LLM, or give my
code to someone else), the case shall be submitted to the Office of the Dean of
Students. Academic penalties up to and including an F in the course are likely.

UT EID 1: vvv348
"""

import sys

# ----------------------------------
# Data structures provided in starter
# ----------------------------------

class Node:
    """Represents a node in a singly linked list."""
    def __init__(self, data, next=None):
        self.data = data
        self.next = next

class StackError(Exception):

class Stack:
    def __init__(self):
        self._top = None
        self._size = 0
    def is_empty(self):
        return self._top is None
    def push(self, item):
        self._top = Node(item, self._top)
        self._size += 1
    def pop(self):
        if self.is_empty():
            raise StackError("Pop from empty stack.")
        item = self._top.data
        self._top = self._top.next
        self._size -= 1
        return item
    def peek(self):
        if self.is_empty():
            raise StackError("Peek from empty stack.")
        return self._top.data
    def size(self):
        return self._size

class QueueError(Exception):

class Queue:
    def __init__(self):
        self._front = None
        self._rear = None
        self._size = 0
    def is_empty(self):
        return self._size == 0
    def enqueue(self, item):
        node = Node(item)
        if self.is_empty():
            self._front = self._rear = node
        else:
            self._rear.next = node
            self._rear = node
        self._size += 1
    def dequeue(self):
        if self.is_empty():
            raise QueueError("Dequeue from empty queue.")
        data = self._front.data
        self._front = self._front.next
        if self._front is None:
            self._rear = None
        self._size -= 1
        return data
    def peek(self):
        if self.is_empty():
            raise QueueError("Peek from empty queue.")
        return self._front.data
    def size(self):
        return self._size

class Vertex:
    """Vertex Class with label, visited flag, and depth property."""
    def __init__(self, label):
        self.__label = label
        self.__visited = False
        self.__depth = -1
    @property
    def label(self):
        return self.__label
    @property
    def visited(self):
        return self.__visited
    @visited.setter
    def visited(self, value):
        if not isinstance(value, bool):
            raise ValueError("Visited must be boolean.")
        self.__visited = value
    @property
    def depth(self):
        return self.__depth
    @depth.setter
    def depth(self, value):
        if not isinstance(value, int):
            raise ValueError("Depth must be integer.")
        self.__depth = value
    def __str__(self):
        return str(self.__label)

class Graph:
    """A Class to represent a directed graph of courses."""
    def __init__(self):
        self.vertices = []            # list of Vertex
        self.adjacency_matrix = []    # 2D list
    def has_vertex(self, label):
        return any(v.label == label for v in self.vertices)
    def get_index(self, label):
        for i, v in enumerate(self.vertices):
            if v.label == label:
                return i
        return -1
    def add_vertex(self, label):
        if self.has_vertex(label): return
        self.vertices.append(Vertex(label))
        # expand adjacency matrix
        n = len(self.vertices)
        for row in self.adjacency_matrix:
            row.append(0)
        self.adjacency_matrix.append([0]*n)
    def add_edge(self, start, finish):
        self.adjacency_matrix[start][finish] = 1
    def get_adjacent_vertices(self, idx):
        return [j for j, val in enumerate(self.adjacency_matrix[idx]) if val]

    def compute_depth(self):
        """Compute longest prerequisite chain depth for each vertex."""
        n = len(self.vertices)
        def dfs(i):
            v = self.vertices[i]
            if v.depth >= 0:
                return v.depth
            maxd = 0
            for j in self.get_adjacent_vertices(i):
                d = 1 + dfs(j)
                if d > maxd: maxd = d
            v.depth = maxd
            return maxd
        for i in range(n):
            dfs(i)

    def has_cycle(self):
        """Detect cycle via DFS with recursion stack."""
        n = len(self.vertices)
        visited = [False]*n
        recstack = [False]*n
        def dfs(i):
            visited[i] = True
            recstack[i] = True
            for j in self.get_adjacent_vertices(i):
                if not visited[j]:
                    if dfs(j): return True
                elif recstack[j]:
                    return True
            recstack[i] = False
            return False
        for i in range(n):
            if not visited[i] and dfs(i):
                return True
        return False

    def get_registration_plan(self):
        """Return a 2D list of course labels, max 4 per semester."""
        n = len(self.vertices)
        if n == 0:
            return []
        # compute depths
        self.compute_depth()
        # compute in-degrees
        in_degree = [0]*n
        for u in range(n):
            for v in self.get_adjacent_vertices(u):
                in_degree[v] += 1
        scheduled = [False]*n
        plan = []
        remain = n
        while remain > 0:
            available = [i for i in range(n) if in_degree[i]==0 and not scheduled[i]]
            # sort by depth descending
            available.sort(key=lambda x: self.vertices[x].depth, reverse=True)
            # take up to 4
            sem = available[:4]
            if not sem:
                break
            # mark scheduled and update in-degrees
            for i in sem:
                scheduled[i] = True
            for i in sem:
                for j in self.get_adjacent_vertices(i):
                    in_degree[j] -= 1
            # append labels
            plan.append([self.vertices[i].label for i in sem])
            remain -= len(sem)
        return plan

def main():
    graph = Graph()
    data = sys.stdin.read().splitlines()
    idx = 0
    # number of vertices
    num_v = int(data[idx].strip()); idx+=1
    for _ in range(num_v):
        label = data[idx].strip(); idx+=1
        graph.add_vertex(label)
    num_e = int(data[idx].strip()); idx+=1
    for _ in range(num_e):
        parts = data[idx].split(); idx+=1
        u = graph.get_index(parts[0]); v = graph.get_index(parts[1])
        graph.add_edge(u, v)
    if graph.has_cycle():
        print("Registration plan invalid because a cycle was detected.")
    else:
        print("Valid registration plan detected.")
        graph.compute_depth()
        plan = graph.get_registration_plan()
        print()
        print("Registration plan: ")
        for sem in plan:
            print(sem)

if __name__ == "__main__":
    main()
